%{
package parser

import (
    "fmt"
)

// Lex is called by the parser generated by "go tool yacc" to obtain each
// token. The method is opened before the matching rules block and closed at
// the end of the file.
func (l *OpenMetricsLexer) Lex() token {
    if l.i >= len(l.b) {
        return tEOF
    }
    c := l.b[l.i]
    l.start = l.i

%}

D     [0-9]
L     [a-zA-Z_]
M     [a-zA-Z_:]
C     [^\n]
S     [ ]

%x sComment sMeta1 sMeta2 sLabels sLValue sValue sTimestamp

%yyc c
%yyn c = l.next()
%yyt l.state


%%

#{S}                                  l.state = sComment
<sComment>HELP{S}                     l.state = sMeta1; return tHelp
<sComment>TYPE{S}                     l.state = sMeta1; return tType
<sComment>UNIT{S}                     l.state = sMeta1; return tUnit
<sComment>"EOF"\n?                    l.state = sInit; return tEOFWord
<sMeta1>\"(\\.|[^\\"])*\"             l.state = sMeta2; return tMName
<sMeta1>{M}({M}|{D})*                 l.state = sMeta2; return tMName
<sMeta2>{S}{C}*\n                     l.state = sInit; return tText

{M}({M}|{D})*                         l.state = sValue; return tMName
<sValue>\{                            l.state = sLabels; return tBraceOpen
\{                                    l.state = sLabels; return tBraceOpen
<sLabels>{L}({L}|{D})*                return tLName
<sLabels>\"(\\.|[^\\"])*\"            l.state = sLabels; return tQString
<sLabels>\}                           l.state = sValue; return tBraceClose
<sLabels>=                            l.state = sLValue; return tEqual
<sLabels>,                            return tComma
<sLValue>\"(\\.|[^\\"\n])*\"          l.state = sLabels; return tLValue
<sValue>{S}[^ \n]+                    l.state = sTimestamp; return tValue
<sTimestamp>{S}[^ \n]+                return tTimestamp
<sTimestamp>\n                        l.state = sInit; return tLinebreak


%%

    return tInvalid
}
